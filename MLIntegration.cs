using System;
using System.Diagnostics;
using System.IO;
using System.Text;
using System.Text.Json;
using System.Text.Json.Serialization;

namespace Multi_Layer_Spoofing_Detector
{

    public class MLIntegration
    {
        private const int ANALYSIS_TIMEOUT_MS = 900_000; 
        private const string DOCKER_IMAGE = "multi-layer-spoof-detector";

        public async Task<MLAnalysisResult> AnalyzePcapAsync(
            string pcapFilePath,
            IProgress<string>? progress = null)
        {
            try
            {
                progress?.Report("Initializing analysis pipeline...");

                if (!File.Exists(pcapFilePath))
                    throw new FileNotFoundException($"PCAP file not found: {pcapFilePath}");

                progress?.Report("Pipeline: PCAP → CICFlowMeter → ML Inference");

                string csvPath = await RunCICFlowMeterAsync(pcapFilePath, progress);
                string jsonOutput = await RunMLAsync(csvPath, progress);

                return ParseAnalysisResult(jsonOutput);
            }
            catch (Exception ex)
            {
                return new MLAnalysisResult
                {
                    Status = "error",
                    ErrorMessage = ex.Message
                };
            }
        }

        private async Task<string> RunCICFlowMeterAsync(string pcapFilePath, IProgress<string>? progress)
        {
            string baseDir = Path.Combine(
                Environment.GetFolderPath(Environment.SpecialFolder.LocalApplicationData),
                "MLSD",
                "cicflowmeter_work"
            );

            string runId = DateTime.Now.ToString("yyyyMMdd_HHmmss");
            string workDir = Path.Combine(baseDir, runId);

            string inputDir = Path.Combine(workDir, "input");
            string outputDir = Path.Combine(workDir, "output");

            Directory.CreateDirectory(inputDir);
            Directory.CreateDirectory(outputDir);

            string pcapName = Path.GetFileName(pcapFilePath);
            string stagedPcap = Path.Combine(inputDir, pcapName);
            File.Copy(pcapFilePath, stagedPcap, true);

            progress?.Report("Running CICFlowMeter (Docker)...");

            var psi = new ProcessStartInfo
            {
                FileName = "docker",
                Arguments =
                    "run --rm " +
                    $"--mount type=bind,source=\"{inputDir}\",target=/pcap/input " +
                    $"--mount type=bind,source=\"{outputDir}\",target=/pcap/output " +
                    "cicflowmeter /pcap/input /pcap/output",
                UseShellExecute = false,
                RedirectStandardOutput = true,
                RedirectStandardError = true,
                CreateNoWindow = true
            };

            using var process = new Process { StartInfo = psi };

            var stdout = new StringBuilder();
            var stderr = new StringBuilder();

            process.OutputDataReceived += (_, e) =>
            {
                if (string.IsNullOrWhiteSpace(e.Data)) return;
                stdout.AppendLine(e.Data);

                // surface progress lines
                if (e.Data.Contains("Working on"))
                    progress?.Report($"CICFlowMeter: {e.Data}");
                else if (e.Data.Contains("Completed"))
                    progress?.Report("CICFlowMeter: Completed.");
            };

            process.ErrorDataReceived += (_, e) =>
            {
                if (string.IsNullOrWhiteSpace(e.Data)) return;
                stderr.AppendLine(e.Data);
            };

            process.Start();
            process.BeginOutputReadLine();
            process.BeginErrorReadLine();

            var completed = await Task.WhenAny(process.WaitForExitAsync(), Task.Delay(ANALYSIS_TIMEOUT_MS));
            if (completed is not Task && !process.HasExited)
            {
                try { process.Kill(true); } catch { }
                throw new TimeoutException($"CICFlowMeter exceeded timeout of {ANALYSIS_TIMEOUT_MS / 1000} seconds.");
            }

            if (process.ExitCode != 0)
            {
                throw new Exception(
                    "CICFlowMeter failed\n\n" +
                    "STDOUT:\n" + stdout + "\n\n" +
                    "STDERR:\n" + stderr
                );
            }

            var csvFiles = Directory.GetFiles(outputDir, "*.csv");
            if (csvFiles.Length == 0)
                throw new Exception("No CSV generated by CICFlowMeter");

            return csvFiles.OrderByDescending(File.GetCreationTimeUtc).First();
        }


        private async Task<string> RunMLAsync(string csvPath, IProgress<string>? progress)
        {
            return await Task.Run(() =>
            {
                string csvDir = Path.GetDirectoryName(csvPath)!;
                string csvFile = Path.GetFileName(csvPath);

                progress?.Report("Running ML inference (Docker)...");

                var psi = new ProcessStartInfo
                {
                    FileName = "docker",
                    UseShellExecute = false,
                    RedirectStandardOutput = true,
                    RedirectStandardError = true,
                    CreateNoWindow = true
                };

                psi.ArgumentList.Add("run");
                psi.ArgumentList.Add("--rm");
                psi.ArgumentList.Add("-v");
                psi.ArgumentList.Add($"{csvDir}:/data");
                psi.ArgumentList.Add(DOCKER_IMAGE);
                psi.ArgumentList.Add("analyze");
                psi.ArgumentList.Add($"/data/{csvFile}");

                using var process = new Process { StartInfo = psi };

                string lastJson = "";
                var stdout = new StringBuilder();
                var stderr = new StringBuilder();

                process.OutputDataReceived += (_, e) =>
                {
                    if (string.IsNullOrWhiteSpace(e.Data)) return;
                    stdout.AppendLine(e.Data);
                    if (e.Data.TrimStart().StartsWith("{"))
                        lastJson = e.Data;
                };

                process.ErrorDataReceived += (_, e) =>
                {
                    if (string.IsNullOrWhiteSpace(e.Data)) return;
                    stderr.AppendLine(e.Data);
                };

                process.Start();
                process.BeginOutputReadLine();
                process.BeginErrorReadLine();

                if (!process.WaitForExit(ANALYSIS_TIMEOUT_MS))
                {
                    try { process.Kill(true); } catch { }
                    throw new TimeoutException($"ML container exceeded timeout of {ANALYSIS_TIMEOUT_MS / 1000} seconds.");
                }

                if (process.ExitCode != 0)
                {
                    throw new Exception(
                        "ML container failed\n\nSTDOUT:\n" + stdout +
                        "\n\nSTDERR:\n" + stderr
                    );
                }

                if (string.IsNullOrWhiteSpace(lastJson))
                    throw new Exception("No JSON output from ML container");

                return lastJson;
            });
        }

        private MLAnalysisResult ParseAnalysisResult(string json)
        {
            try
            {
                var options = new JsonSerializerOptions
                {
                    PropertyNameCaseInsensitive = true
                };

                var result = JsonSerializer.Deserialize<MLAnalysisResult>(json, options);

                if (result == null)
                    throw new Exception("Empty ML response");

                result.Arp_Spoofing ??= new List<ThreatDetection>();
                result.Dns_Spoofing ??= new List<ThreatDetection>();
                result.Ip_Spoofing ??= new List<ThreatDetection>();

                return result;
            }
            catch (JsonException ex)
            {
                throw new Exception($"Failed to parse ML output:\n{ex.Message}\n\n{json}");
            }
        }
    }


    public class MLAnalysisResult
    {
        public string Status { get; set; }
        public string ErrorMessage { get; set; }

        [JsonPropertyName("total_packets")]
        public int Total_Packets { get; set; }

        [JsonPropertyName("arp_spoofing")]
        public List<ThreatDetection> Arp_Spoofing { get; set; }

        [JsonPropertyName("dns_spoofing")]
        public List<ThreatDetection> Dns_Spoofing { get; set; }

        [JsonPropertyName("ip_spoofing")]
        public List<ThreatDetection> Ip_Spoofing { get; set; }
    }

    public class ThreatDetection
    {
        public string Type { get; set; }
        public double Confidence { get; set; }
        public string Details { get; set; }
        public string Src_Ip { get; set; }
    }
}
