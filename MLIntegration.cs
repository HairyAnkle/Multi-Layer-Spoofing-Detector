using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using System.Text;
using System.Text.Json;
using System.Text.Json.Serialization;
using System.Threading.Tasks;

namespace Multi_Layer_Spoofing_Detector
{

    public class MLIntegration
    {
        private const int ANALYSIS_TIMEOUT_MS = 900_000; 
        private const string DOCKER_IMAGE = "multi-layer-spoof-detector";

        public async Task<MLAnalysisResult> AnalyzePcapAsync(
            string pcapFilePath,
            IProgress<string>? progress = null)
        {
            try
            {
                progress?.Report("Initializing analysis pipeline...");

                if (!File.Exists(pcapFilePath))
                    throw new FileNotFoundException($"PCAP file not found: {pcapFilePath}");

                progress?.Report("Pipeline: PCAP → CICFlowMeter → ML Inference");

                string csvPath = await RunCICFlowMeterAsync(pcapFilePath, progress);
                string jsonOutput = await RunMLAsync(csvPath, progress);

                return ParseAnalysisResult(jsonOutput);
            }
            catch (Exception ex)
            {
                return new MLAnalysisResult
                {
                    Status = "error",
                    ErrorMessage = ex.Message
                };
            }
        }

        private async Task<string> RunCICFlowMeterAsync(
            string pcapFilePath,
            IProgress<string>? progress)
        {
            return await Task.Run(() =>
            {
                string workDir = Path.Combine(
                    Path.GetDirectoryName(pcapFilePath)!,
                    "cicflowmeter_work"
                );

                string inputDir = Path.Combine(workDir, "input");
                string outputDir = Path.Combine(workDir, "output");

                Directory.CreateDirectory(inputDir);
                Directory.CreateDirectory(outputDir);

                string pcapName = Path.GetFileName(pcapFilePath);
                File.Copy(pcapFilePath, Path.Combine(inputDir, pcapName), true);

                progress?.Report("Running CICFlowMeter (Docker)");

                var psi = new ProcessStartInfo
                {
                    FileName = "docker",
                    Arguments =
                        $"run --rm " +
                        $"-v \"{workDir}:/tmp/pcap\" " +
                        $"cicflowmeter /tmp/pcap/input /tmp/pcap/output",
                    UseShellExecute = false,
                    RedirectStandardOutput = true,
                    RedirectStandardError = true,
                    CreateNoWindow = true
                };

                using var process = Process.Start(psi)!;
                process.WaitForExit();

                if (process.ExitCode != 0)
                    throw new Exception("CICFlowMeter failed");

                var csvFiles = Directory.GetFiles(outputDir, "*.csv");
                if (csvFiles.Length == 0)
                    throw new Exception("No CSV generated by CICFlowMeter");

                return csvFiles.OrderByDescending(File.GetCreationTime).First();
            });
        }

        private async Task<string> RunMLAsync(
            string csvPath,
            IProgress<string>? progress)
        {
            return await Task.Run(() =>
            {
                string csvDir = Path.GetDirectoryName(csvPath)!;
                string csvFile = Path.GetFileName(csvPath);

                progress?.Report("Running ML inference (Docker)");

                var psi = new ProcessStartInfo
                {
                    FileName = "docker",
                    Arguments =
                        $"run --rm " +
                        $"-v \"{csvDir}:/data\" " +
                        $"{DOCKER_IMAGE} analyze /data/{csvFile}",
                    UseShellExecute = false,
                    RedirectStandardOutput = true,
                    RedirectStandardError = true,
                    CreateNoWindow = true
                };

                using var process = new Process { StartInfo = psi };

                string lastJson = "";
                var stdout = new System.Text.StringBuilder();
                var stderr = new System.Text.StringBuilder();

                process.OutputDataReceived += (_, e) =>
                {
                    if (string.IsNullOrWhiteSpace(e.Data)) return;
                    stdout.AppendLine(e.Data);
                    if (e.Data.TrimStart().StartsWith("{"))
                        lastJson = e.Data;
                };
                process.ErrorDataReceived += (_, e) =>
                {
                    if (string.IsNullOrWhiteSpace(e.Data)) return;
                    stderr.AppendLine(e.Data);
                };

                process.Start();
                process.BeginOutputReadLine();
                process.BeginErrorReadLine();
                if (!process.WaitForExit(ANALYSIS_TIMEOUT_MS))
                {
                    try
                    {
                        process.Kill(true);
                    }
                    catch (InvalidOperationException)
                    {
                    }

                    throw new TimeoutException(
                        $"ML container exceeded timeout of {ANALYSIS_TIMEOUT_MS / 1000} seconds."
                    );
                }

                if (process.ExitCode != 0)
                {
                    string debugMessage =
                        "ML container failed\n\n" +
                        "STDOUT:\n" + stdout.ToString() + "\n\n" +
                        "STDERR:\n" + stderr.ToString();

                    throw new Exception(debugMessage);
                }

                if (string.IsNullOrEmpty(lastJson))
                    throw new Exception("No JSON output from ML container");

                return lastJson;
            });
        }

        private MLAnalysisResult ParseAnalysisResult(string json)
        {
            try
            {
                var options = new JsonSerializerOptions
                {
                    PropertyNameCaseInsensitive = true
                };

                var result = JsonSerializer.Deserialize<MLAnalysisResult>(json, options);

                if (result == null)
                    throw new Exception("Empty ML response");

                result.Arp_Spoofing ??= new List<ThreatDetection>();
                result.Dns_Spoofing ??= new List<ThreatDetection>();
                result.Ip_Spoofing ??= new List<ThreatDetection>();

                return result;
            }
            catch (JsonException ex)
            {
                throw new Exception($"Failed to parse ML output:\n{ex.Message}\n\n{json}");
            }
        }
    }


    public class MLAnalysisResult
    {
        public string Status { get; set; }
        public string ErrorMessage { get; set; }

        [JsonPropertyName("total_packets")]
        public int Total_Packets { get; set; }

        [JsonPropertyName("arp_spoofing")]
        public List<ThreatDetection> Arp_Spoofing { get; set; }

        [JsonPropertyName("dns_spoofing")]
        public List<ThreatDetection> Dns_Spoofing { get; set; }

        [JsonPropertyName("ip_spoofing")]
        public List<ThreatDetection> Ip_Spoofing { get; set; }
    }

    public class ThreatDetection
    {
        public string Type { get; set; }
        public double Confidence { get; set; }
        public string Details { get; set; }
        public string Src_Ip { get; set; }
    }
}
